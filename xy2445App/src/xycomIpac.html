<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Andy Foster">
   <title>EPICS Support for the Xycom-9660 IP Carrier Board and 3 IP Modules</title>
</head>
<body bgcolor="#00FFFF">

<center>
<h1>
EPICS Support for the Xycom-9660 IP Carrier Board and 3 IP Modules</h1>

Version 1.0

<address>
Andy Foster, Observatory Sciences Limited, Cambridge, UK</address></center>

<ol>

<li><a href="#section1">Introduction</a></li>
<li><a href="#section2">Definitions, Acronyms and Abbreviations</a></li>
<p></p>
<li><a href="#section3">Xycom-9660 Carrier Board</a></li>
<ul>
  <li><a href="#section3.1">Hardware</a></li>
  <ul>
    <li><a href="#section3.1.1">Jumper Settings</a></li>
  </ul>
  <li><a href="#section3.2">Software</a></li>
</ul>
<p></p>
<li><a href="#section4">Xycom-2440 Digital Input Module</a></li>
<ul>
  <li><a href="#section4.1">Hardware</a></li>
  <ul>
    <li><a href="#section4.1.1">Jumper Settings</a></li>
  </ul>
  <li><a href="#section4.2">Software</a></li>
  <ul>
    <li><a href="#section4.2.1">The vxWorks Interface</a></li>
    <ul>
      <li><a href="#xy2440Report">xy2440Report</a></li>
      <li><a href="#xy2440Initialise">xy2440Initialise</a></li>
      <li><a href="#xy2440Create">xy2440Create</a></li>
      <li><a href="#xy2440Read">xy2440Read</a></li>
    </ul>
    <li><a href="#section4.2.2">The vxWorks Startup Script</a></li>
    <li><a href="#section4.2.3">The EPICS Interface</a></li>
    <li><a href="#section4.2.4">The EPICS Startup Script</a></li>
  </ul>
</ul>
<p></p>
<li><a href="#section5">Xycom-2445 Digital Output Module</a></li>
<ul>
  <li><a href="#section5.1">Hardware</a></li>
  <ul>
    <li><a href="#section5.1.1">Jumper Settings</a></li>
  </ul>
  <li><a href="#section5.2">Software</a></li>
  <ul>
    <li><a href="#section5.2.1">The vxWorks Interface</a></li>
    <ul>
      <li><a href="#xy2445Report">xy2445Report</a></li>
      <li><a href="#xy2445Initialise">xy2445Initialise</a></li>
      <li><a href="#xy2445Create">xy2445Create</a></li>
      <li><a href="#xy2445Read">xy2445Read</a></li>
      <li><a href="#xy2445Write">xy2445Write</a></li>
    </ul>
    <li><a href="#section5.2.2">The vxWorks Startup Script</a></li>
    <li><a href="#section5.2.3">The EPICS Interface</a></li>
    <li><a href="#section5.2.4">The EPICS Startup Script</a></li>
  </ul>
</ul>
<p></p>
<li><a href="#section6">Xycom-5320 Analog Input Module</a></li>
<ul>
  <li><a href="#section6.1">Hardware</a></li>
  <ul>
    <li><a href="#section6.1.1">Jumper Settings</a></li>
  </ul>
  <li><a href="#section6.2">Software</a></li>
  <ul>
    <li><a href="#section6.2.1">The vxWorks Interface</a></li>
    <ul>
      <li><a href="#xy5320Report">xy5320Report</a></li>
      <li><a href="#xy5320Initialise">xy5320Initialise</a></li>
      <li><a href="#xy5320Create">xy5320Create</a></li>
      <li><a href="#xy5320ReadChannel">xy5320ReadChannel</a></li>
      <li><a href="#xy5320ReadArray">xy5320ReadArray</a></li>
    </ul>
    <li><a href="#section6.2.2">The vxWorks Startup Script</a></li>
    <li><a href="#section6.2.3">The EPICS Interface</a></li>
    <li><a href="#section6.2.4">The EPICS Startup Script</a></li>
  </ul>
</ul>
<p></p>
<li><a href="#section7">Where to find the software</a></li>

</ol>

<hr>


<h1>
<a NAME="section1"></a>1. Introduction</h1>

<p>The Gemini Multi-Conjugate Adaptive
Optics System project has decided to adopt Xycom as its manufacturer of choice
to supply an IPAC carrier board and various IPAC modules. The motivation for
using IPAC is to be able to provide cost effective functionality in one VME
slot. There are a range of IPAC modules that provide functionality such as
digital I/O and analog I/O. Since the carrier board is capable of hosting 4
modules and occupies one VME slot, we can tailor this slot to provide the
desired mixture of digital and analog I/O.</p>

<p>The Xycom IPAC carrier board and its
various modules did not have software support already available from the EPICS
community. As part of the MCAO project, we have developed this support and the
details of its use are documented here. In particular, we have developed EPICS
support for the carrier board and 3 modules. These modules are:</p>

<ul>
<li>
The Xycom-2440 32-Channel Isolated Digital Input Module with Interrupts
<li>
The Xycom-2445 32-Channel Digital Output Module
<li>
The Xycom-5320 12-bit Analog Input Module
</ul>

<hr>
<h1>
<a NAME="section2"></a>2. Definitions, Acronyms and Abbreviations</h1>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("ADC\t\tAnalog-to-Digital Converter\r")
document.write("AI\t\tAnalog Input (EPICS record type)\r")
document.write("BI\t\tBinary Input (EPICS record type)\r")
document.write("BO\t\tBinary Output (EPICS record type)\r")
document.write("DBD\t\tDataBase Definition\r")
document.write("EPICS\t\tExperimental Physics and Industrial Control System\r")
document.write("genSub\t\tGeneral Subroutine (EPICS record type)\r")
document.write("I/O\t\tInput/Output\r")
document.write("IPAC\t\tIndustry Pack\r")
document.write("ISR\t\tInterrupt Service Routine\r")
document.write("MBBI\t\tMult-Bit Binary Input (EPICS record type)\r")
document.write("MBBO\t\tMult-Bit Binary Output (EPICS record type)\r")
document.write("MBBIDIRECT\tMult-Bit Binary Input Direct (EPICS record type)\r")
document.write("MBBODIRECT\tMult-Bit Binary Output Direct (EPICS record type)\r")
document.write("MCAO\t\tMult-Conjugate Adaptive Optics\r")
document.write("SSR\t\tSolid State Relay\r")
document.write("TTL\t\tTransistor-Transistor Logic\r")
document.write("VME\t\tVersa Module Eurocard (the meaning is now obsolete)\r")
document.write("vxWorks\t\tA Real-Time Operating System from Wind River Inc.\r")
document.write("Xycom\t\tA company which provides VME hardware\r")
document.write("</XMP>")
</SCRIPT>
</hr>

<hr>
<h1>
<a NAME="section3"></a>3. Xycom-9660 Carrier Board</h1>

<h2>
<a NAME="section3.1"></a>3.1 Hardware</h2>

<p>The Xycom-9660 is a non-intelligent, 6U
high, VME board. It provides an interface to the VME backplane for up to 4 IPAC
modules. Data access is through the front panel. All data and register access
to the IP modules are available as offsets from the base address of the carrier
board. The front panel contains 4 LED's that indicate successful access to each
of the on-board IPAC modules, this is very helpful in debugging problems. The
carrier board supports two interrupt requests per IPAC module. It effectively
maps these interrupts to one of the seven available interrupt request lines on
the VME backplane.</p>

<h3>
<a NAME="section3.1.1"></a>3.1.1 Jumper Settings</h3>

<p>There is one
bank of jumpers on this board that allows the base address of the board to be
configured. The carrier board is shipped with a default factory setting of <i>0x0000</i>.
The carrier board interfaces with the VMEbus as a 1K byte block of address
locations in the VMEbus short I/O address space.</p>

<h2>
<a NAME="section3.2"></a>3.2 Software</h2>

<p>The way in which a driver for an IPAC
carrier board is implemented within EPICS follows a very well defined
methodology. Essentially, there is a generic IPAC 
driver already available for
EPICS and each new carrier board needs to provide certain functions to
interface to this generic driver. The generic driver is called
&quot;drvIpac&quot; and was developed by Andrew Johnson (see his description
at <a href="http://www.aps.anl.gov/asd/people/anj/ipac/drvIpac.html">drvIpac</a>). 
We have followed this approach in 
implementing the EPICS support for this carrier board. Essentially, 
four interface functions have been written:</p>

<ul>
<li>
<i>Initialise</i>
</ul>

<p>This function is called from
&quot;ipacAddCarrier&quot; which itself is called from within the vxWorks/EPICS
startup script. The purpose of this function is to probe the VME memory space
to make sure that communication with the board is possible and to initialise
the board by setting the appropriate registers as required.</p>

<ul>
<li>
<i>baseAddr</i>
</ul>

<p>This function returns the base address,
given a slot number on the carrier board and an address space. Note that many
IPAC modules use two address spaces, this is because the IPAC module itself can
have memory onboard. Typically the I/O base address of the module is in A16
space whilst any onboard memory is mapped into A24 space. We do not have to
worry about this with the modules we have chosen for MCAO because none of them
contain any onboard memory.</p>

<ul>
<li>
<i>irqCmd</i>
</ul>

<p>This function sets up interrupt control
handling. Typically, it will enable the VME interrupt address level being used.
We use level 6 for handling interrupts. This is the highest priority
non-maskable interrupt level permitted by the VME specification.</p>

<ul>
<li>
<i>report</i>
</ul>

<p>This function returns information about
the status of the module in each slot of the carrier board. It is called from
&quot;ipacReport&quot;, which is usually called from the vxWorks shell.</p>

<p>For the user of the Xycom-9660 carrier
board software, the details of the four functions above are immaterial. The
most important public function that the user will need to understand is
&quot;ipacAddCarrier&quot; which is part of the generic IPAC driver.</p>

<b>int ipacAddCarrier(ipac_carrier_t *pcarrier, char *cardParams);</b>

<p>This routine
should be called from the vxWorks/EPICS start-up script. It registers a
particular carrier board with the generic IPAC driver. It must be called once
for each carrier board in the system. The order is which carriers are
registered with this routine defines the carrier number they will be allocated,
starting from zero for the first board registered.</p>

<p>The first
argument to the routine is a pointer to the carrier descriptor table. In the
case of the Xycom-9660 board, this will always be <b><i>&amp;xy9660</i></b>.</p>

<p>For the
Xycom-9660 board, the second argument will be the base address of the carrier
board, e.g. <b><i>&quot;0x0400&quot;</i></b>. This base address must agree with
that selected via the hardware jumpers on the carrier board itself.</p>

<p>When called, the
function checks that the carrier descriptor table looks sensible, calls the
&quot;initialise&quot; routine (as described above), then saves the carrier
private pointer and carrier table address in an internal array. The card number
allows the same descriptor table to be used for all carriers of the same type
i.e. all Xycom-9660 carrier boards use the same descriptor table.</p>

<p>Note that the
driver can be used without EPICS by compiling the code with the flag
&quot;-D NO_EPICS&quot;.</p>

<hr>
<h1>
<a NAME="section4"></a>4. The Xycom-2440 Digital Input Module</h1>

<h2>
<a NAME="section4.1"></a>4.1 Hardware</h2>

<p>The Xycom-2440 Digital Input Module
allows for the monitoring of 32 optically-isolated inputs. It is a high-speed
board for which zero wait states are required. Access times for all data
transfer cycles are described in terms of &quot;wait&quot; states. Zero wait
states implies that all cycles complete in 250ns. There are three different
models of this particular board allowing a selection of input ranges from +/-4 to
+/-60 volts. The board we have chosen for MCAO operates in the +/-4 to +/-18 volt
range.</p>

<p>The board is capable of generating an
interrupt for a change in each input channel. Whether the interrupt is
generated for a low-to-high or a high-to-low transition is software
programmable through an event register. Since this register occupies 1 byte and
there are 32 inputs, the resolution for controlling the interrupts is 4
channels (nibble) per bit of the event register. Note that we can detect both
types of transition for a single input channel but to do this requires
bi-wiring of the channels with a wire jumper at the termination panel.</p>

<p>For each set of 8 input channels (defined
as a port), we can configure the debounce time through software. The debounce
time is the amount of time that must elapse before a transition to a new state
is confirmed to have taken place.</p>

<h3>
<a NAME="section4.1.1"></a>4.1.1 Jumper Settings</h3>

<p>There are no jumper settings for this module.</p>

<h2>
<a NAME="section4.2"></a>4.2 Software</h2>

<p>Two software modules have been written
for this card, &quot;drvXy2440.c&quot; and &quot;devXy2440.c&quot;. These
correspond to the vxWorks/EPICS device driver and EPICS device support
respectively. The device driver can be compiled for use with vxWorks only by
compiling with the &quot;-D NO_EPICS&quot; directive.</p>

<p>This module can be configured through
software to run in two different modes: standard mode and enhanced mode. The
difference between the modes is that interrupts are only generated in enhanced
mode and debounce is only configurable in enhanced mode.</p>

<h3>
<a NAME="section4.2.1"></a>4.2.1 The vxWorks Interface</h3>

<p>The vxWorks interface is provided by a
set of four functions. We describe their use below.</p>

<hr>
<pre><b><a NAME="xy2440Report">int xy2440Report( int interest );</b></pre>

<p>This function is
typically run from the vxWorks shell although it could easily be called from a
user function. It prints out information about the state of all Xycom-2440
cards in the system. The parameter <i>interest </i>determines the amount of
information given. There are three supported choices of this parameter: 0, 1
and 2. The two outputs for interest levels 0 and 1 are shown below. Using an
interest level of 2 returns both sets of information.</p>

<p><i>68k->xy2440Report 0</i></p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("Board Status Information:\tbi1\r")
document.write("\r")
document.write("Interrupt Enable Register:\t01\r")
document.write("Interrupt Vector Register:\tff\r")
document.write("Last Interrupting Channel:\t1f\r")
document.write("Last Interrupting State:\t00\r")
document.write("Identification:\t\t\tIPAC\r")
document.write("Manufacturer's ID:\t\ta3\r")
document.write("IP Model Number:\t\t10\r")
document.write("Revision:\t\t\t0\r")
document.write("Reserved:\t\t\t0\r")
document.write("Driver I.D.(low):\t\t0\r")
document.write("Driver I.D.(high):\t\t0\r")
document.write("Total I.D. Bytes:\t\tc\r")
document.write("CRC:\t\t\t\t3b\r")
document.write("</XMP>")
</SCRIPT>

<p><i>68k->xy2440Report 1</i></p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("Board Pattern: bi1\r")
document.write("--------------\r")
document.write("              Bits\r")
document.write("        0 1 2 3 4 5 6 7\r")
document.write("        ---------------\r")
document.write("Port 0: 0 0 0 0 0 0 0 1\r")
document.write("Port 1: 1 1 0 0 0 0 0 0\r")
document.write("Port 2: 1 1 0 0 0 0 0 0\r")
document.write("Port 3: 0 0 0 0 0 0 0 1\r")
document.write("</XMP>")
</SCRIPT>

<hr>
<pre><b><a NAME="xy2440Initialise">int xy2440Initialise( void );</b></pre>

<p>This function is responsible for
connecting the interrupt service routine to the interrupt vector and for
enabling the appropriate VME interrupt line (level 6 is used). In standard
mode, this routine effectively does nothing. However, it is good practice to
always call this routine from your vxWorks start-up script. It must be called
after <i>xy2440Create</i>, which is described in detail in the next section.
Note the routine will only return an error if the connection between ISR and
interrupt vector cannot be made.</p>

<hr>
<pre><b><a NAME="xy2440Create">int xy2440Create( char *name, ushort_t card, ushort_t slot, 
                  char *modeName, char *intHandlerName, char *usrFunc, short vector, 
                  short event, short debounce );</b></pre>

<p>This function is responsible for creating
the software entity that will control a particular Xycom-2440 module in the
system. It must always be called from the vxWorks start-up script. It will
configure the registers in memory according to the parameters specified as
inputs to this function. We now describe in detail, the meaning of each
parameter.</p>

<dd><b>char *name</b></dd>

<p>This is a unique name for this particular
module in the system. Any ASCII string beginning with a letter is acceptable.
Examples are &quot;bi1&quot;, &quot;Digital1&quot;. Further use of this
parameter is made in the EPICS interface.</p>

<dd><b>ushort_t card</b></dd>

<p>The number of the carrier board in which
this module is located.<span style="mso-spacerun: yes">\240 </span>Remember that
carrier boards are assigned values beginning at zero and incrementing with each
call to &quot;<i>ipacAddCarrier</i>&quot;.</p>

<dd><b>ushort_t slot</b></dd>

<p>The number of the slot on the carrier
board in which this module is located. The Xycom-9660 carrier board actually
labels its slots A, B, C &amp; D. These map to 0, 1, 2 &amp; 3 when specifying
this parameter.</p>

<dd><b>char *modeName</b></dd>

<p>This defines the mode in which we want to
run the module. There are two possible values: STANDARD or ENHANCED. As stated
earlier, interrupts and debounce control are only available in enhanced mode.</p>

<dd><b>char *intHandlerName</b></dd>

<p>This defines the type of interrupts we
are configuring for this module. There are two possibilities: COS or LEVEL. COS
is an abbreviation for change-of-state and refers to interrupts being generated
for both low-to-high and high-to-low transitions on the same channel. Note that
to use change-of-state operation, the user must physically connect input bits 0
&amp; 4, 1 &amp; 5, 2 &amp; 6 and 3 &amp; 7 of each port, at the termination
panel. This obviously reduces the number of inputs for the card from 32 to 16.
LEVEL specifies that interrupts will only
be generated on one particular transition (low-to-high or high-to-low) for each
bit. In this mode, all 32 bits are available for use. The choice of this parameter
will decide which of the two ISR's, supplied with the driver, will be called
when an interrupt occurs.</p>

<dd><b>char *usrFunc</b></dd>

<p>This is the name of a user function that,
if specified, will be called from the COS or LEVEL interrupt service routine.
The user's routine will be passed the name of the board generating the
interrupt and the interrupting port and bit numbers according to the following
prototype: </p>
<pre>usrFunc( char *name, int port, int bit )</pre>
<p>If the user does specify a routine, it
must be loaded in the vxWorks startup script prior to <i>xy2440Create</i> being
called. If the user does not want to specify a routine, then <i>0x0</i> should
be entered here.</p>

<dd><b>short vector</b></dd>

<p>This is the interrupt vector number to be
used. The valid range is 0-255, however, vector numbers below 64 are reserved
on the MVME167 board for system components.</p>

<dd><b>short event</b></dd>

<p>This byte defines which transitions of
the input channels will cause an interrupt. Each bit of <i>event </i>controls 4
input channels according to the following list:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("Bit 0 = 0:\tLow-to-High\tPort 0\tInput Channels 0-3\r")
document.write("Bit 0 = 1:\tHigh-to-Low\tPort 0\tInput Channels 0-3\r")
document.write("Bit 1 = 0:\tLow-to-High\tPort 0\tInput Channels 4-7\r")
document.write("Bit 1 = 1:\tHigh-to-Low\tPort 0\tInput Channels 4-7\r")
document.write("Bit 2 = 0:\tLow-to-High\tPort 1\tInput Channels 0-3\r")
document.write("Bit 2 = 1:\tHigh-to-Low\tPort 1\tInput Channels 0-3\r")
document.write("Bit 3 = 0:\tLow-to-High\tPort 1\tInput Channels 4-7\r")
document.write("Bit 3 = 1:\tHigh-to-Low\tPort 1\tInput Channels 4-7\r")
document.write("Bit 4 = 0:\tLow-to-High\tPort 2\tInput Channels 0-3\r")
document.write("Bit 4 = 1:\tHigh-to-Low\tPort 2\tInput Channels 0-3\r")
document.write("Bit 5 = 0:\tLow-to-High\tPort 2\tInput Channels 4-7\r")
document.write("Bit 5 = 1:\tHigh-to-Low\tPort 2\tInput Channels 4-7\r")
document.write("Bit 6 = 0:\tLow-to-High\tPort 3\tInput Channels 0-3\r")
document.write("Bit 6 = 1:\tHigh-to-Low\tPort 3\tInput Channels 0-3\r")
document.write("Bit 7 = 0:\tLow-to-High\tPort 3\tInput Channels 4-7\r")
document.write("Bit 7 = 1:\tHigh-to-Low\tPort 3\tInput Channels 4-7\r")
document.write("</XMP>")
</SCRIPT>

<dd><b>short debounce</b></dd>

<p>This byte controls the debounce time for
each output port. Two bits of <i>debounce</i> per port are required to select
one of 4 possible time ranges as follows:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("debounce Bit 0:\tPort 0 time select bit 0\r")
document.write("debounce Bit 1:\tPort 0 time select bit 1\r")
document.write("debounce Bit 2:\tPort 1 time select bit 0\r")
document.write("debounce Bit 3:\tPort 1 time select bit 1\r")
document.write("debounce Bit 4:\tPort 2 time select bit 0\r")
document.write("debounce Bit 5:\tPort 2 time select bit 1\r")
document.write("debounce Bit 6:\tPort 3 time select bit 0\r")
document.write("debounce Bit 7:\tPort 3 time select bit 1\r")
document.write("</XMP>")
</SCRIPT>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("Time Select Bits (1,0)\t Time\r")
document.write("----------------------\t ----\r")
document.write("     00\t\t\t 3-4    microseconds\r")
document.write("     01\t\t\t 48-64  microseconds\r")
document.write("     10\t\t\t 0.75-1 millisecond\r")
document.write("     11\t\t\t 6-8    milliseconds\r")
document.write("</XMP>")
</SCRIPT>

<hr>
<pre><b><a NAME="xy2440Read">long xy2440Read( char *name, short port, short bit, int readFlag,
                 unsigned short *pval, int debug );</b></pre>

<p>This function is responsible for reading
a single input channel or a group of input channels. We now describe in detail,
the meaning of each parameter.</p>

<dd><b>char *name</b></dd>

<p>The unique name which identifies this
particular module in the system.</p>

<dd><b>short port</b></dd>

<p>The number of the port we want to read
from. Ports are numbered from 0 to 3.</p>

<dd><b>short bit</b></dd>

<p>The number of the bit, within the port,
we wish to read. Bits are numbered from 0 to 7.</p>

<dd><b>int readFlag</b></dd>

<p>This parameter defines the amount of data
to read. There are 4 possibilities, defined as an enumerated type in <i>drvXy2440.h</i>.
These are:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("BIT:\tRead a single bit\r")
document.write("NIBBLE:\tRead 4 bits, beginning at the port and bit number defined in the call\r")
document.write("PORT:\tRead the port specified in the \"port\" parameter\r")
document.write("WORD:\tRead 16 bits, beginning at the port and bit number defined in the call\r")
document.write("</XMP>")
</SCRIPT>

<dd><b>unsigned short *pval</b></dd>

<p>This is the location of the returned data.</p>

<dd><b>int debug</b></dd>

<p>This is flag which controls debug statements
within this function. A value of 0 suppresses debug statements, a value of 1
forces debug statements to be printed out.</p>

<hr>
<h3>
<a NAME="section4.2.2"></a>4.2.2 The vxWorks Startup Script</h3>

<p>Lines similar to the following must be
placed in the vxWorks startup script:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("xy2440Create \"bi1\", 0, 0, \"ENHANCED\", \"LEVEL\", 0x0, 0xFF, 0x3, 0xFF\r")
document.write("xy2440Initialise\r")
document.write("</XMP>")
</SCRIPT>

<p>Note that a separate call to <i>xy2440Create</i>
is necessary for each Xycom-2440 module in the system. Only one call to <i>xy2440Initialise</i>
is necessary as this initializes all the modules.</p>

<hr>
<h3>
<a NAME="section4.2.3"></a>4.2.3 The EPICS Interface</h3>

<p>The EPICS interface is defined by the
device support that has been written to support this module. Within the EPICS
software architecture, the device support layer links EPICS records to the
device driver layer. Device support has been written for the BI, MBBI and
MBBIDIRECT EPICS records.
Within an EPICS input record, the
communication link to the hardware is configured through two fields, the DTYP
field and the INP link. For the Xycom-2440 module, these fields should be
specified as follows:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("DTYP = \"XYCOM-2440\"\r")
document.write("INP  = @name P<p> B<b>\r")
document.write("</XMP>")
</SCRIPT>

<p>Here, <i>name,</i> is the unique name of
this module within the system. This should always be the same as that specified
as the first parameter in the call to <i>xy2440Create.</i></p>

<p><i>&lt;p&gt;</i> is the port number we wish to read from.</p>
<p><i>&lt;b&gt;</i> is the bit number we wish to read from.</p>

<p>For the MBBI and MBBIDIRECT records, it
is essential to configure the NOBT field. This is the number of bits you wish
to read. An MBBI record is capable of reading up to and including 4 bits, an
MBBIDIRECT record is capable of reading up to and including 16 bits. The read
will begin at the position indicated by the <i>P</i> and <i>B</i> parameters in
the INP link specification.</p>

<p>It is worth pointing out two important
differences between the EPICS support for the Xycom-2440 module and EPICS
support for the Xycom-240 digital I/O board which is distributed as part of
EPICS base:</p>

<p><ul><li>The support for this new IPAC module supports true interrupts. In
the case of the Xycom-240 card, the driver polls the inputs at 30 Hz and then
simulates interrupts for &quot;I/O Intr&quot; scanned records using the EPICS
callback mechanism.</li></ul></p>

<p><ul><li>By defining an EPICS IOSCANPVT pointer for each input channel on the
IPAC module, we are able to distinguish which input channel caused the
interrupt. This in turn means that we can force only those records that are
linked to that particular channel process on interrupt. In the case of the
Xycom-240 driver, all records set to &quot;I/O Intr&quot; will process when any
bit changes regardless of whether the record is monitoring that particular bit.</li></ul></p>

<hr>
<h3>
<a NAME="section4.2.4"></a>4.2.4 The EPICS Startup Script</h3>

<p>A single line, for each Xycom-2440 module, similar to the following should be
placed in the startup script:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("xy2440Create \"bi1\", 0, 0, \"ENHANCED\", \"LEVEL\", 0x0, 0xFF, 0x3, 0xFF\r")
document.write("</XMP>")
</SCRIPT>

<p>The explicit call to <i>xy2440Initialise</i>, as shown in the vxWorks startup script,
is unnecessary as this will be called automatically when EPICS initializes via the
execution of <i>iocCore</i>.</p>

<hr>
<h1>
<a NAME="section5"></a>5. Xycom-2445 Digital Output Module</h1>

<h2>
<a NAME="section5.1"></a>5.1 Hardware</h2>

<p>The Xycom-2445 module allows control of
up to 32 optically isolated outputs. This is achieved via 32 bipolar SSR's. It
is a high-speed board for which zero wait states are required. Access times for
all data transfer cycles are described in terms of &quot;wait&quot; states.
Zero wait states implies that all cycles complete in 250ns. This module is
loop-back compatible with the Xycom-2440 module. The output channels are split
into 4 ports of 8 channels. Each group of 8 channels can be connected to common
for low side switching. In this configuration, the module is TTL compatible. For
safety reasons, when the module is powered-up or a system reset occurs, the
SSR's will be disabled and the outputs are turned off.</p>

<h3>
<a NAME="section5.1.1"></a>5.1.1 Jumper Settings</h3>

<p>There are no jumper settings for this module.</p>

<h2>
<a NAME="section5.2"></a>5.2 Software</h2>

<p>Two software modules have been written
for this card, &quot;drvXy2445.c&quot; and &quot;devXy2445.c&quot;. These
correspond to the vxWorks/EPICS device driver and EPICS device support
respectively. The device driver can be compiled for use with vxWorks only by
compiling with the &quot;-D NO_EPICS&quot; directive.</p>

<h3>
<a NAME="section5.2.1"></a>5.2.1 The vxWorks Interface</h3>

<p>The vxWorks interface is provided by a
set of five functions. We describe their use below.</p>

<hr>
<pre><b><a NAME="xy2445Report">int xy2445Report( int interest );</b></pre>

<p>This function is
typically run from the vxWorks shell although it could easily be called from a
user function. It prints out information about the state of all Xycom-2445
cards in the system. The parameter <i>interest </i>determines the amount of
information given. There are three supported choices of this parameter: 0, 1
and 2. The two outputs for interest levels 0 and 1 are shown below. Using an
interest level of 2 returns both sets of information.</p>

<p><i>68k->xy2445Report 0</i></p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("Board Status Information:\tbo1\r")
document.write("\r")
document.write("Identification:\t\t\tIPAC\r")
document.write("Manufacturer's ID:\t\ta3\r")
document.write("IP Model Number:\t\t9\r")
document.write("Revision:\t\t\t0\r")
document.write("Reserved:\t\t\t0\r")
document.write("Driver I.D.(low):\t\t0\r")
document.write("Driver I.D.(high):\t\t0\r")
document.write("Total I.D. Bytes:\t\tc\r")
document.write("CRC:\t\t\t\t8c\r")
document.write("</XMP>")
</SCRIPT>

<p><i>68k->xy2445Report 1</i></p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("Board Pattern: bo1\r")
document.write("--------------\r")
document.write("              Bits\r")
document.write("        0 1 2 3 4 5 6 7\r")
document.write("        ---------------\r")
document.write("Port 0: 0 0 0 0 0 0 0 1\r")
document.write("Port 1: 1 1 0 0 0 0 0 0\r")
document.write("Port 2: 1 1 0 0 0 0 0 0\r")
document.write("Port 3: 0 0 0 0 0 0 0 1\r")
document.write("</XMP>")
</SCRIPT>

<hr>
<pre><b><a NAME="xy2445Initialise">int xy2445Initialise( void );</b></pre>

<p>This is a null
function that does not perform any duties. It is included so that the driver is
compliant with the EPICS interface.</p>

<hr>
<pre><b><a NAME="xy2445Create">int xy2445Create( char *name, ushort_t card, ushort_t slot );
</b></pre>

<p>This function is responsible for creating
the software entity that will control a particular Xycom-2445 module in the
system. It must always be called from the vxWorks start-up script. It will
configure the registers in memory according to the parameters specified as
inputs to this function. We now describe in detail, the meaning of each
parameter.</p>

<dd><b>char *name</b></dd>

<p>This is a unique name for this particular
module in the system. Any ASCII string beginning with a letter is acceptable.
Examples are &quot;bo1&quot;, &quot;Digital1&quot;. Further use of this
parameter is made in the EPICS interface.</p>

<dd><b>ushort_t card</b></dd>

<p>The number of the carrier board in which
this module is located.<span style="mso-spacerun: yes">\240 </span>Remember that
carrier boards are assigned values beginning at zero and incrementing with each
call to &quot;<i>ipacAddCarrier</i>&quot;.</p>

<dd><b>ushort_t slot</b></dd>

<p>The number of the slot on the carrier
board in which this module is located. The Xycom-9660 carrier board actually
labels its slots A, B, C &amp; D. These map to 0, 1, 2 &amp; 3 when specifying
this parameter.</p>

<hr>
<pre><b><a NAME="xy2445Read">long xy2445Read( char *name, short port, short bit, int readFlag,
                 unsigned short *pval, int debug );</b></pre>

<p>This function is responsible for reading
a single output channel or a group of output channels. We now describe in
detail, the meaning of each parameter.</p>

<dd><b>char *name</b></dd>

<p>The unique name which identifies this
particular module in the system.</p>

<dd><b>short port</b></dd>

<p>The number of the port we want to read
from. Ports are numbered from 0 to 3.</p>

<dd><b>short bit</b></dd>

<p>The number of the bit, within the port,
we wish to read. Bits are numbered from 0 to 7.</p>

<dd><b>int readFlag</b></dd>

<p>This parameter defines the amount of data
to read. There are 4 possibilities, defined as an enumerated type in <i>drvXy2445.h</i>.
These are:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("BIT:\tRead a single bit\r")
document.write("NIBBLE:\tRead 4 bits, beginning at the port and bit number defined in the call\r")
document.write("PORT:\tRead the port specified in the \"port\" parameter\r")
document.write("WORD:\tRead 16 bits, beginning at the port and bit number defined in the call\r")
document.write("</XMP>")
</SCRIPT>

<dd><b>unsigned short *pval</b></dd>

<p>This is the location of the returned data.</p>

<dd><b>int debug</b></dd>

<p>This is flag
which controls debug statements within this function. A value of 0 suppresses
debug statements, a value of 1 forces debug statements to be printed out.</p>

<hr>
<pre><b><a NAME="xy2445Write">long xy2445Write( char *name, short port, short bit, int writeFlag,
                 long value, int debug );</b></pre>

<p>This function is responsible for writing to
a single output channel or a group of output channels. We now describe in
detail, the meaning of each parameter.</p>

<dd><b>char *name</b></dd>

<p>The unique name which identifies this
particular module in the system.</p>

<dd><b>short port</b></dd>

<p>The number of the port we want to write
to. Ports are numbered from 0 to 3.</p>

<dd><b>short bit</b></dd>

<p>The number of the bit, within the port,
we wish to write to. Bits are numbered from 0 to 7.</p>

<dd><b>int writeFlag</b></dd>

<p>This parameter defines the amount of data
to write. There are 4 possibilities, defined as an enumerated type in <i>drvXy2445.h</i>.
These are:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("BIT:\tWrite a single bit\r")
document.write("NIBBLE:\tWrite 4 bits, beginning at the port and bit number defined in the call\r")
document.write("PORT:\tWrite the port specified in the \"port\" parameter\r")
document.write("WORD:\tWrite 16 bits, beginning at the port and bit number defined in the call\r")
document.write("</XMP>")
</SCRIPT>

<dd><b>long value</b></dd>

<p>The value to be written.</p>

<dd><b>int debug</b></dd>

<p>This is flag
which controls debug statements within this function. A value of 0 suppresses
debug statements, a value of 1 forces debug statements to be printed out.</p>

<hr>
<h3>
<a NAME="section5.2.2"></a>5.2.2 The vxWorks Startup Script</h3>

<p>A line similar to the following must be
placed in the vxWorks startup script:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("xy2440Create \"bo1\", 0, 1\r")
document.write("</XMP>")
</SCRIPT>

<p>Note that a separate call to <i>xy2445Create</i>
is necessary for each Xycom-2445 module in the system.</p>

<hr>
<h3>
<a NAME="section5.2.3"></a>5.2.3 The EPICS Interface</h3>

<p>The EPICS interface is defined by the
device support that has been written to support this module. Within the EPICS
software architecture, the device support layer links EPICS records to the
device driver layer. Device support has been written for the BO, MBBO and
MBBODIRECT EPICS records.
Within an EPICS output record, the
communication link to the hardware is configured through two fields, the DTYP
field and the OUT link. For the Xycom-2445 module, these fields should be
specified as follows:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("DTYP = \"XYCOM-2445\"\r")
document.write("OUT  = @name P<p> B<b>\r")
document.write("</XMP>")
</SCRIPT>

<p>Here, <i>name,</i> is the unique name of
this module within the system. This should always be the same as that specified
as the first parameter in the call to <i>xy2445Create.</i></p>

<p><i>&lt;p&gt;</i> is the port number we wish to write to.</p>
<p><i>&lt;b&gt;</i> is the bit number we wish to write to.</p>

<p>For the MBBO and
MBBODIRECT records, it is essential to configure the NOBT field. This is the
number of bits you wish to write. An MBBO record is capable of writing up to
and including 4 bits, an MBBODIRECT record is capable of writing up to and including
16 bits. The write will begin at the position indicated by the <i>P</i> and <i>B</i>
parameters in the OUT link specification.</p>

<hr>
<h3>
<a NAME="section5.2.4"></a>5.2.4 The EPICS Startup Script</h3>

<p>The EPICS
startup script entry is identical to the vxWorks startup script entry above.</p>

<hr>
<h1>
<a NAME="section6"></a>6. Xycom-5320 Analog Input Module</h1>

<h2>
<a NAME="section6.1"></a>6.1 Hardware</h2>

<p>The Xycom-5320 module allows monitoring
of up to 20 differential or 40 single-ended channels. Each analog value is
converted to a 12-bit digital value using a successive approximation ADC with
an 8.5\265s conversion time. The board is capable of a maximum system throughput
of 100,000 samples per second using the pipe-lined mode of operation. In this
mode, the board is configured to read the next channel while the current
channel is being converted.</p>

<p>Input acquisition can be triggered via
software or by an external hardware input for synchronization to external
events. One nice feature of the board is that it contains four voltage sources
and an analog ground reference to enable automatic calibration. The gain of
each channel is separately configurable through software. Valid values for the
gain are 1, 2, 4 or 8.</p>

<h3>
<a NAME="section6.1.1"></a>6.1.1 Jumper Settings</h3>

<p>This module contains two banks of
jumpers. One bank enables the input voltage range to be selected, the other
bank enables an external or internal power supply to be used. One of three
input voltage ranges can be chosen: -5 to +5 V, -10 to +10 V or 0 to +10 V. For
the power, if the internal supply is chosen, then the +/- 12 V back-plane source
is used via the P1 connector. If the external supply is chosen the user must supply
a +/- 15 V power source via the P2 connector. Note that the input voltage ranges:
-10 to +10 V and 0 to +10 V can only be achieved by using an external power
source, otherwise the digitized values will be clipped.</p>

<h2>
<a NAME="section6.2"></a>6.2 Software</h2>

<p>Two software modules have been written
for this card, &quot;drvXy5320.c&quot; and &quot;devXy5320.c&quot;. These
correspond to the vxWorks/EPICS device driver and EPICS device support
respectively. The device driver can be compiled for use with vxWorks only by
compiling with the &quot;-D NO_EPICS&quot; directive.</p>

<h3>
<a NAME="section6.2.1"></a>6.2.1 The vxWorks Interface</h3>

<p>The vxWorks interface is provided by a
set of five functions. We describe their use below.</p>

<hr>
<pre><b><a NAME="xy5320Report">int xy5320Report( int interest );</b></pre>

<p>This function is typically run from the
vxWorks shell although it could easily be called from a user function. It
prints out information about the state of all Xycom-5320 cards in the system.
The parameter <i>interest</i> is not actually used by the function, so the same
information will be obtained for all values of <i>interest</i>. An example of
the output from this function is given below.</p>

<p><i>68k->xy5320Report</i></p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("Board Status Information:\tai1\r")
document.write("\r")
document.write("Identification:\t\t\tIPAC\r")
document.write("Manufacturer's ID:\t\ta3\r")
document.write("IP Model Number:\t\t32\r")
document.write("Revision:\t\t\t0\r")
document.write("Reserved:\t\t\t0\r")
document.write("Driver I.D.(low):\t\t0\r")
document.write("Driver I.D.(high):\t\t0\r")
document.write("Total I.D. Bytes:\t\tc\r")
document.write("CRC:\t\t\t\t2e\r")
document.write("</XMP>")
</SCRIPT>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("Chan = 0:  raw    = 0x8f70, auto-zero = 0x7ff3, cal = 0xfd11, corrected = 0x8f8\r")
document.write("           analog = +0.606571\r")
document.write("Chan = 1:  raw    = 0x70ab, auto-zero = 0x8001, cal = 0xfd10, corrected = 0x709\r")
document.write("           analog = -0.600887\r")
document.write("Chan = 6:  raw    = 0x9ef1, auto-zero = 0x8007, cal = 0xfd39, corrected = 0x9ef\r")
document.write("           analog = +1.209940\r")
document.write("Chan = 7:  raw    = 0x6167, auto-zero = 0x8009, cal = 0xfd2e, corrected = 0x614\r")
document.write("           analog = -1.199419\r")
document.write("Chan = 12: raw    = 0xbdf0, auto-zero = 0x801c, cal = 0xfd50, corrected = 0xbdf\r")
document.write("           analog = +2.419730\r")
document.write("Chan = 13: raw    = 0x42dd, auto-zero = 0x801c, cal = 0xfd44, corrected = 0x429\r")
document.write("           analog = -2.397850\r")
document.write("Chan = 18: raw    = 0xfbe8, auto-zero = 0x8032, cal = 0xfd58, corrected = 0xfbf\r")
document.write("           analog = +4.843717\r")
document.write("</XMP>")
</SCRIPT>

<p>So, for each channel configured at boot time, the following information is given:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("raw:\t\tThis is the digitized value of the raw analog input\r")
document.write("auto-zero:\tThis is the digitized value of the analog ground reference\r")
document.write("cal:\t\tThis is the digitized value of the calibration source\r")
document.write("corrected:\tThis is the digitized value after calibration corrections\r")
document.write("\t\thave been applied\r")
document.write("analog:\t\tThis is the analog value calculated from the corrected digitized value\r")
document.write("</XMP>")
</SCRIPT>

<hr>
<pre><b><a NAME="xy5320Initialise">int xy5320Initialise( void );</b></pre>

<p>This function is responsible for starting
two tasks. One of these tasks calibrates all the xy5320 modules in the system
every twenty minutes. The other task reads all the configured input channels,
on all the xy5320 modules, into memory at 20 Hz. It then calculates the
corrected digitized value by using the calibration data. This function must be
called from the vxWorks startup script after the call to <i>xy5320Create</i>.</p>

<hr>
<pre><b><a NAME="xy5320Create">int xy5320Create( char *name, ushort_t card, ushort_t slot, 
                  char *voltRangeName, char *modeName, int numSamples,
                  char *filename );</b></pre>

<p>This function is responsible for creating
the software entity that will control a particular Xycom-5320 module in the
system. It must be called once from the vxWorks start-up script for each
Xycom-5320 module. It will configure the registers in memory according to the
parameters specified as inputs to this function. We now describe in detail, the
meaning of each parameter.</p>

<dd><b>char *name</b></dd>

<p>This is a unique name for this particular
module in the system. Any ASCII string beginning with a letter is acceptable.
Examples are &quot;ai1&quot;, &quot;Analog1&quot;. Further use of this
parameter is made in the EPICS interface.</p>

<dd><b>ushort_t card</b></dd>

<p>The number of the carrier board in which
this module is located. Remember that
carrier boards are assigned values beginning at zero and incrementing with each
call to &quot;<i>ipacAddCarrier</i>&quot;.</p>

<dd><b>ushort_t slot</b></dd>

<p>The number of the slot on the carrier
board in which this module is located. The Xycom-9660 carrier board actually
labels its slots A, B, C &amp; D. These map to 0, 1, 2 &amp; 3 when specifying
this parameter.</p>

<dd><b>char *voltRangeName</b></dd>

<p>This is a string representing the voltage
range over which the board will operate. There are three valid choices:
&quot;-5TO5&quot;, &quot;-10TO10&quot; or &quot;0TO10&quot;. Please note that
the board jumpers need changing as well, when a new voltage range is selected.</p>

<dd><b>char *modeName</b></dd>

<p>This is a string representing the type of
inputs we are dealing with. There are two valid choices: &quot;DIF&quot; or
&quot;SE&quot;. These correspond to Differential and Single-ended respectively.</p>

<dd><b>int numSamples</b></dd>

<p>This is the number of times every input
channel is read before an average value for each channel is calculated. Note
that increasing the size of this parameter can have drastic effects on the CPU
usage. Typically, a value of 16 reduces the noise and results in a smooth
output.</p>

<dd><b>char *filename</b></dd>

<p>This is the name of a file that contains
the numbers of the configured channels and their respective gains. The full
pathname to the file should be specified if the file is not located in the
local directory. The file itself has a very simple format. There should be two
columns separated by at least one space. The first column contains channel
numbers, the second column contains the gain settings. Remember there are 4
valid gain settings, these are: 1, 2, 4 &amp; 8. Example contents of this file
would be:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("0\t1\r")
document.write("6\t2\r")
document.write("12\t4\r")
document.write("18\t8\r")
document.write("</XMP>")
</SCRIPT>

<p>This configures the module so that only 4
channels will read. Channel 0 will have a gain of 1, channel 6 will have a gain
of 2, channel 12 will have a gain of 4 and channel 18 will have a gain of 8.</p>

<p>The information specified in this file is
very important as it essentially controls which channels will be read and what gain
will be applied until the next time the system is rebooted. Note that it is
possible to specify the same channel any number of times, each with a different
gain setting if desired.</p>

<hr>
<pre><b><a NAME="xy5320ReadChannel">long xy5320ReadChannel( char *name, int channel, 
                        unsigned long ftvl, void *prval );</b></pre>

<p>This function is responsible for reading
a single input channel. We now describe in detail, the meaning of each
parameter.</p>

<dd><b>char *name</b></dd>

<p>The unique name which identifies this particular module in the system.</p>

<dd><b>char *channel</b></dd>

<p>The number of the channel we wish to read from.</p>

<dd><b>unsigned long ftvl</b></dd>

<p>The data type we wish to read. There are
2 possibilities, defined as an enumerated type in <i>drvXy5320.h</i>. These
are:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("TYPE_LONG:\tRead the corrected digitized value\r")
document.write("TYPE_DOUBLE:\tRead the analog value\r")
document.write("</XMP>")
</SCRIPT>

<dd><b>void *prval</b></dd>

<p>This is the location of the returned
data. Note that sufficient space must be passed into this routine for the data
to be copied into.</p>

<hr>
<pre><b><a NAME="xy5320ReadArray">long xy5320ReadArray( char *name, int startIndex, int numChan,
                      unsigned long ftvl, void *prval );
</b></pre>

<p>This function is responsible for reading an array of input channels.
We now describe in detail, the meaning of each parameter.</p>

<dd><b>char *name</b></dd>

<p>The unique name which identifies this particular module in the system.</p>

<dd><b>int startIndex</b></dd>

<p>The index of the start channel within the
file named in the call to <i>xy5320Create</i>. The index begins at 0 for the
first channel in the file.</p>

<dd><b>int numChan</b></dd>

<p>The number of channel values to be read.</p>

<dd><b>unsigned long ftvl</b></dd>

<p>The data type we wish to read. There are
2 possibilities, defined as an enumerated type in <i>drvXy5320.h</i>. These
are:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("TYPE_LONG:\tRead the corrected digitized value\r")
document.write("TYPE_DOUBLE:\tRead the analog value\r")
document.write("</XMP>")
</SCRIPT>

<dd><b>void *prval</b></dd>

<p>This is the location of the returned
data. Note that sufficient space must be passed into this routine for the data
to be copied into.</p>

<hr>
<h3>
<a NAME="section6.2.2"></a>6.2.2 The vxWorks Startup Script</h3>

<p>Two lines similar to the following must be placed in the vxWorks startup script:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("xy5320Create \"ai1\", 0, 2, \"-5TO5\", \"SE\", 16, \"gains.dat\"\r")
document.write("xy5320Initialise\r")
document.write("</XMP>")
</SCRIPT>

<p>Note that a
separate call to <i>xy5320Create</i> is necessary for each Xycom-5320 module in
the system. Only one call to <i>xy5320Initialise</i> is necessary as this
initializes all the modules.</p>

<hr>
<h3>
<a NAME="section6.2.3"></a>6.2.3 The EPICS Interface</h3>

<p>The EPICS interface is defined by the
device support that has been written to support this module. Within the EPICS
software architecture, the device support layer links EPICS records to the
device driver layer. Device support has been written for the AI and the
Waveform EPICS records. Within an EPICS input record, the
communication link to the hardware is configured through two fields, the
DTYP field and the INP link. For the Xycom-5320
module, these fields should be specified as follows:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("DTYP = \"XYCOM-5320\"\r")
document.write("OUT  = @name C<c>\r")
document.write("</XMP>")
</SCRIPT>

Here, <i>name,</i> is the unique name of
this module within the system. This should always be the same as that specified
as the first parameter in the call to <i>xy5320Create.</i></p>

<p>In the next two paragraphs, <i>filename</i>,
refers to the file named in the call to <i>xy5320Create</i>.
For the AI record, <i>&lt;c&gt; </i> is
the channel number we wish to read from. This must have previously been
configured through <i>filename</i>. For the Waveform record, <i>&lt;c&gt;</i>
is no longer the channel number. It is the index of the channel in <i>filename </i> at
which we want the array to begin.</p>

<p>The FTVL field within the Waveform record
allows the user to specify the type of data within the array. This device
support uses the setting of this field to decide whether to return the
corrected digitized values (FTVL=LONG) or the analog values (FTVL=DOUBLE).
The Waveform
record contains a field, NELM that usually specifies the number of channels to
be read. It is slightly different for this device support. NELM must be set to
twice the number of channels you wish to read plus 1. That is:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("NELM = 2 * Number of desired channels + 1\r")
document.write("</XMP>")
</SCRIPT>

<p>The reason is as
follows. We want to return not only the analog values of the channels but the
channel numbers themselves and the number of elements read. The format of the
returned array is as follows:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("array[0]   = Number of elements read\r")
document.write("array[1]   = First channel number\r")
document.write("array[2]   = Second channel number\r")
document.write("...\r")
document.write("array[n]   = nth channel number\r")
document.write("array[n+1] = First channel value\r")
document.write("array[n+2] = Second channel value\r")
document.write("...\r")
document.write("array[2*n] = nth channel value\r")
document.write("</XMP>")
</SCRIPT>

<p>The reason for
returning all of these values in a single array is to circumvent the problem of
atomic Channel Access &quot;gets&quot;. If these data were split between 2 or 3
different record fields, then it would always be possible to obtain a dataset
that is inconsistent. By using an array, we do not have this problem.</p>

<p>Note that the
output from the Waveform record can be connected to an input of a genSub record
and the values of the array can be manipulated with ease.</p>

<hr>
<h3>
<a NAME="section6.2.4"></a>6.2.4 The EPICS Startup Script</h3>

<p>A single line, for each Xycom-5320 module, similar to the following should
be placed in the startup script:</p>

<SCRIPT LANGUAGE='Javascript'>
document.write("<XMP>")
document.write("xy5320Create \"ai1\", 0, 2, \"-5TO5\", \"SE\", 16, \"gains.dat\"\r")
document.write("</XMP>")
</SCRIPT>

<p>The explicit
call to <i>xy5320Initialise</i>,<i> </i>as shown in the vxWorks startup script,
is unnecessary as this will be called automatically when EPICS initializes via
the execution of <i>iocCore</i>.</p>

<hr>
<h1>
<a NAME="section7"></a>7. Where to find the software</h1>

<p>
The software is available for download from the link given in the table
below:
</p>

<blockquote>
<table border=1>
<tr>
<th>Version</th>
<th>EPICS Release</th>
<th>Filename</th>
</tr>

<tr>
<td><align=center>1.0</td>
<td>R3.13.x</td>
<td><a href="http://www.observatorysciences.co.uk/ajf/xycomIpac-1.0.tar.gz">xycomIpac-1.0.tar.gz</a></td>
</tr>

</table>
</blockquote>

<p>
When expanded, the gzipped tar file contains a simple three level directory structure.
The top-level directory will be called <i>xycomIpac</i>, under which will be found
<i>src</i>. Under <i>src</i> there are 4 directories: <i>xy2440</i>, 
<i>xy2445</i>, <i>xy5320</i> and <i>xy9660</i>. The driver, device support and
DBD files for each module can be found in the appropriate directory.
To build these into your application:
</p>

<ul> 
  <li>Include the "C" files and DBD files in your application <i>src</i> directory,
  modify your Makefile's appropriately and build the binaries.</li>
  <li> Load the DBD files and the binaries in your startup script.</li>
  <li> Add appropriate <i>create</i> routines to the startup script
  as described in the sections above.</li>
</ul>

<hr>

<address>
Andy Foster
<a href="mailto:ajf@observatorysciences.co.uk">&lt;ajf@observatorysciences.co.uk&gt;</a></address>

</body>
</html>
